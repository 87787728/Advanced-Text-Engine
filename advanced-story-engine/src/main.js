const readline = require('readline');
const StoryEngine = require('./core/StoryEngine');

class GameInterface {
    constructor() {
        this.engine = null;
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
        
        this.commands = {
            'help': this.showHelp.bind(this),
            'stats': this.showStats.bind(this),
            'status': this.showStatus.bind(this),
            'save': this.saveGame.bind(this),
            'load': this.loadGame.bind(this),
            'analyze': this.analyzeWorld.bind(this),
            'relationships': this.showRelationships.bind(this),
            'inventory': this.showInventory.bind(this),
            'quit': this.quit.bind(this),
            'exit': this.quit.bind(this)
        };
    }
    
    async initialize() {
        console.log("üé≠ Advanced Dynamic Story Engine v2.0");
        console.log("üåü A sophisticated world that grows and evolves with every choice!");
        console.log("‚ïê".repeat(70));
        
        const apiKey = await this.askQuestion("üîë Enter your Gemini API key: ");
        
        if (!apiKey.trim()) {
            console.log("‚ùå API key required to run the advanced story engine!");
            process.exit(1);
        }
        
        console.log("\n‚ö° Initializing advanced systems...");
        this.engine = new StoryEngine(apiKey);
        
        console.log("‚úÖ All systems operational!");
        console.log("\nType 'help' for commands or start your adventure!\n");
        
        // Check for existing save
        const loadSave = await this.askQuestion("üìÅ Load existing save? (y/N): ");
        if (loadSave.toLowerCase().startsWith('y')) {
            const success = await this.engine.loadGame();
            if (!success) {
                console.log("üÜï Starting new adventure instead!");
            }
        }
        
        // Generate initial story if new game
        if (this.engine.meta.choiceCount === 0) {
            await this.generateInitialStory();
        }
    }
    
    async generateInitialStory() {
        console.log("\nüé≤ Generating your opening story...\n");
        
        const response = await this.engine.processPlayerChoice(
            "I find myself in the village square, taking in my surroundings and considering my opportunities in this new place. I want to understand the local dynamics and find my place in this community."
        );
        
        console.log(response.narrative);
        
        if (response.newEntitiesCount > 0) {
            console.log(`\n‚ú® ${response.newEntitiesCount} new entities added to your world!`);
        }
    }
    
    async gameLoop() {
        while (true) {
            try {
                const input = await this.askQuestion("\n> What do you choose? ");
                
                if (this.commands[input.toLowerCase()]) {
                    await this.commands[input.toLowerCase()]();
                    continue;
                }
                
                // Process as story choice
                console.log("\nüé≤ Processing your choice...\n");
                const response = await this.engine.processPlayerChoice(input);
                
                console.log(response.narrative);
                
                // Show creation results if any
                if (response.newEntitiesCount > 0) {
                    console.log(`\n‚ú® ${response.newEntitiesCount} new entities added to your world!`);
                    
                    if (response.creationResults.warnings.length > 0) {
                        console.log("\n‚ö†Ô∏è Warnings:");
                        response.creationResults.warnings.forEach(warning => 
                            console.log(`  ‚Ä¢ ${warning}`)
                        );
                    }
                }
                
                // Auto-save every few choices
                if (this.engine.meta.choiceCount % 5 === 0) {
                    await this.engine.saveGame();
                }
                
            } catch (error) {
                console.error("\nüí• Error processing input:", error.message);
                console.log("üîß The world stabilizes as reality reasserts itself...\n");
            }
        }
    }
    
    async showHelp() {
        console.log("\nüìú ADVANCED STORY ENGINE COMMANDS");
        console.log("‚ïê".repeat(50));
        console.log("üéÆ GAMEPLAY:");
        console.log("  help          - Show this help");
        console.log("  stats         - Display comprehensive world state");
        console.log("  status        - Show engine system status");
        console.log("  relationships - Show detailed relationship networks");
        console.log("  inventory     - Show player inventory and items");
        console.log("  analyze       - Analyze current world state");
        console.log("");
        console.log("üíæ SAVE/LOAD:");
        console.log("  save          - Save current game state");
        console.log("  load          - Load saved game state");
        console.log("  quit/exit     - Save and quit game");
        console.log("");
        console.log("üåü ADVANCED FEATURES:");
        console.log("  ‚Ä¢ Multi-dimensional relationship tracking (trust, fear, respect, love)");
        console.log("  ‚Ä¢ Dynamic faction politics and territorial control");
        console.log("  ‚Ä¢ Skill-based choice consequences with progression");
        console.log("  ‚Ä¢ Complex world events with lasting global impact");
        console.log("  ‚Ä¢ Advanced memory and narrative consistency engine");
        console.log("  ‚Ä¢ Procedural world expansion with intelligent validation");
        console.log("  ‚Ä¢ Sophisticated reputation system across multiple domains");
        console.log("  ‚Ä¢ Real-time world state analysis and trend prediction");
        console.log("‚ïê".repeat(50));
    }
    
    async showStats() {
        const gameState = this.engine.getDetailedGameState();
        
        console.log("\nüìä COMPREHENSIVE WORLD STATE");
        console.log("‚ïê".repeat(80));
        
        // Player Overview
        console.log("üßô PLAYER PROFILE:");
        console.log(`   Name: ${gameState.player.name} (Level ${gameState.player.level})`);
        console.log(`   Location: ${gameState.player.currentLocation}`);
        console.log(`   Health: ${gameState.player.health}/${gameState.player.maxHealth}`);
        console.log(`   Experience: ${gameState.player.experience}`);
        console.log(`   Mood: ${gameState.player.mood}`);
        
        // Reputation
        console.log("\nüëë REPUTATION PROFILE:");
        Object.entries(gameState.player.reputation).forEach(([type, value]) => {
            const emoji = value > 10 ? "üìà" : value < -10 ? "üìâ" : "üìä";
            const status = value > 20 ? "High" : value > 5 ? "Moderate" : value < -20 ? "Very Low" : value < -5 ? "Low" : "Neutral";
            console.log(`   ${emoji} ${type.charAt(0).toUpperCase() + type.slice(1)}: ${value > 0 ? '+' : ''}${value} (${status})`);
        });
        
        // Skills with progress bars
        console.log("\n‚öîÔ∏è SKILL MASTERY:");
        Object.entries(gameState.player.skills).forEach(([skill, level]) => {
            const bar = "‚ñà".repeat(Math.floor(level/5)) + "‚ñë".repeat(20 - Math.floor(level/5));
            const mastery = level >= 80 ? "Expert" : level >= 60 ? "Advanced" : level >= 40 ? "Skilled" : level >= 20 ? "Competent" : "Novice";
            console.log(`   ${skill.padEnd(12)}: ${bar} ${level}/100 (${mastery})`);
        });
        
        // Known NPCs with detailed relationships
        console.log("\nüë• CHARACTER RELATIONSHIPS:");
        Object.entries(gameState.entities.npcs).forEach(([id, npc]) => {
            if (npc.met) {
                console.log(`\n   ${npc.name} (${npc.occupation}) - ${npc.location}`);
                console.log(`     Trust: ${npc.trust}/100, Respect: ${npc.respect}/100`);
                console.log(`     Fear: ${npc.fear}/100, Love: ${npc.love}/100`);
                console.log(`     Mood: ${npc.mood}, Importance: ${npc.importance}`);
                if (npc.traits.length > 0) {
                    console.log(`     Traits: ${npc.traits.join(', ')}`);
                }
            }
        });
        
        // Faction Relations
        console.log("\nüèõÔ∏è FACTION DYNAMICS:");
        Object.entries(gameState.entities.factions).forEach(([id, faction]) => {
            const standing = gameState.relationships.playerStandings[id];
            const standingValue = standing ? standing.value : 0;
            const emoji = standingValue > 20 ? "üòä" : standingValue > -20 ? "üòê" : "üò†";
            const relationship = standingValue > 30 ? "Allied" : standingValue > 10 ? "Friendly" : 
                               standingValue > -10 ? "Neutral" : standingValue > -30 ? "Unfriendly" : "Hostile";
            
            console.log(`\n   ${emoji} ${faction.name} (${faction.type})`);
            console.log(`     Player Standing: ${standingValue > 0 ? '+' : ''}${standingValue} (${relationship})`);
            console.log(`     Influence: ${faction.influence}/100, Attitude: ${faction.attitude}`);
            console.log(`     Territory: ${faction.territory.join(', ')}`);
            if (faction.goals.length > 0) {
                console.log(`     Goals: ${faction.goals.join(', ')}`);
            }
        });
        
        // World State
        console.log("\nüåç GLOBAL DYNAMICS:");
        const worldParams = gameState.worldState.globalParameters;
        console.log(`   Global Tension: ${worldParams.tension}/100 ${this.getTensionDescription(worldParams.tension)}`);
        console.log(`   Political Stability: ${worldParams.politicalStability}/100 ${this.getStabilityDescription(worldParams.politicalStability)}`);
        console.log(`   Economic State: ${worldParams.economicState}/100 ${this.getEconomicDescription(worldParams.economicState)}`);
        console.log(`   Magical Activity: ${worldParams.magicalActivity}/100 ${this.getMagicalDescription(worldParams.magicalActivity)}`);
        
        // Time and Environment
        console.log("\nüïê TEMPORAL CONTEXT:");
        const temporal = gameState.worldState.temporal;
        console.log(`   Time: ${temporal.timeOfDay}, Season: ${temporal.season}`);
        console.log(`   Weather: ${temporal.weather}, Day: ${temporal.day}`);
        console.log(`   Month: ${temporal.month}, Year: ${temporal.year}`);
        
        // Active Events
        console.log("\nüìÖ CURRENT EVENTS:");
        if (gameState.worldState.events.current.length > 0) {
            gameState.worldState.events.current.forEach(event => {
                console.log(`   ‚Ä¢ ${event.name} (${event.type}, ${event.scope})`);
                if (event.description) {
                    console.log(`     ${event.description}`);
                }
            });
        } else {
            console.log("   ‚Ä¢ No major events currently active");
        }
        
        // Recent Activity
        console.log("\nüìà RECENT ACTIVITY:");
        if (gameState.analysis) {
            const activity = gameState.analysis.playerProfile.recentActivity;
            console.log(`   Choices Made: ${activity.choicesLastSession}`);
            console.log(`   Locations Visited: ${activity.locationsVisited}`);
            console.log(`   Major Decisions: ${activity.majorDecisions.length}`);
        }
        
        // Creation Statistics
        console.log("\n‚ú® DYNAMIC WORLD STATISTICS:");
        const stats = gameState.analysis.entityStatistics;
        console.log(`   üé≠ NPCs: ${stats.npcs.total} total, ${stats.npcs.met} met, ${stats.npcs.alive} alive`);
        console.log(`   üèõÔ∏è Factions: ${stats.factions.total} total, ${stats.factions.allied} allied, ${stats.factions.hostile} hostile`);
        console.log(`   üó∫Ô∏è Locations: ${stats.locations.total} total, ${stats.locations.visited} visited`);
        console.log(`   üì¶ Items: ${stats.items.total} total, ${stats.items.inInventory} in inventory`);
        console.log(`   üé≤ Total Choices: ${gameState.meta.choiceCount}`);
        console.log(`   ‚è±Ô∏è Session Time: ${Math.floor((Date.now() - gameState.meta.sessionId) / 60000)} minutes`);
        
        console.log("‚ïê".repeat(80));
    }
    
    getTensionDescription(tension) {
        if (tension > 80) return "(üî• Extreme Crisis)";
        if (tension > 60) return "(‚ö° High Tension)";
        if (tension > 40) return "(‚ö†Ô∏è Moderate Tension)";
        if (tension > 20) return "(üòå Low Tension)";
        return "(‚òÆÔ∏è Peaceful)";
    }
    
    getStabilityDescription(stability) {
        if (stability > 80) return "(üèõÔ∏è Very Stable)";
        if (stability > 60) return "(üìä Stable)";
        if (stability > 40) return "(‚öñÔ∏è Uncertain)";
        if (stability > 20) return "(‚ö†Ô∏è Unstable)";
        return "(üí• Chaos)";
    }
    
    getEconomicDescription(economic) {
        if (economic > 80) return "(üí∞ Prosperous)";
        if (economic > 60) return "(üìà Growing)";
        if (economic > 40) return "(üìä Stable)";
        if (economic > 20) return "(üìâ Declining)";
        return "(üí∏ Depressed)";
    }
    
    getMagicalDescription(magical) {
        if (magical > 80) return "(üåü Highly Active)";
        if (magical > 60) return "(‚ú® Active)";
        if (magical > 40) return "(üîÆ Moderate)";
        if (magical > 20) return "(üí´ Low)";
        return "(üö´ Dormant)";
    }
    
    async showStatus() {
        const status = this.engine.getSystemStatus();
        
        console.log("\nüîß SYSTEM STATUS");
        console.log("‚ïê".repeat(50));
        console.log(`Engine: ${status.engine}`);
        console.log(`Status: ${status.status.toUpperCase()}`);
        console.log("");
        console.log("üñ•Ô∏è CORE SYSTEMS:");
        Object.entries(status.systems).forEach(([system, state]) => {
            const emoji = state === 'active' ? '‚úÖ' : '‚ùå';
            console.log(`   ${emoji} ${system}: ${state}`);
        });
        console.log("");
        console.log("üìä PERFORMANCE METRICS:");
        console.log(`   Total Choices Processed: ${status.performance.totalChoices}`);
        console.log(`   Session Duration: ${status.performance.sessionTime} minutes`);
        console.log(`   Entities Created: ${status.performance.entitiesCreated}`);
        console.log(`   Memory Usage: ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB`);
        console.log("‚ïê".repeat(50));
    }
    
    async showRelationships() {
        const gameState = this.engine.getDetailedGameState();
        
        console.log("\nüï∏Ô∏è RELATIONSHIP NETWORKS");
        console.log("‚ïê".repeat(60));
        
        // Player relationship summary
        const summary = gameState.analysis.playerProfile.relationships;
        
        console.log("üë§ YOUR RELATIONSHIPS:");
        console.log("");
        
        if (summary.allies.length > 0) {
            console.log("üòä ALLIES:");
            summary.allies.forEach(ally => {
                console.log(`   ‚Ä¢ ${ally.name}: ${ally.standing > 0 ? '+' : ''}${ally.standing}`);
            });
            console.log("");
        }
        
        if (summary.enemies.length > 0) {
            console.log("üò† ENEMIES:");
            summary.enemies.forEach(enemy => {
                console.log(`   ‚Ä¢ ${enemy.name}: ${enemy.standing}`);
            });
            console.log("");
        }
        
        if (summary.neutral.length > 0) {
            console.log("üòê NEUTRAL:");
            summary.neutral.forEach(neutral => {
                console.log(`   ‚Ä¢ ${neutral.name}: ${neutral.standing > 0 ? '+' : ''}${neutral.standing}`);
            });
            console.log("");
        }
        
        // NPC relationship networks
        console.log("üîó NPC NETWORKS:");
        Object.entries(gameState.analysis.relationshipNetworks).forEach(([npcId, network]) => {
            const npc = gameState.entities.npcs[npcId];
            if (npc && npc.met && network.directConnections > 0) {
                console.log(`\n   ${npc.name}:`);
                console.log(`     Connections: ${network.directConnections}`);
                console.log(`     Allies: ${network.allies}, Enemies: ${network.enemies}`);
                console.log(`     Network Influence: ${network.networkInfluence}`);
                if (network.mostTrusted) {
                    const trusted = gameState.entities.npcs[network.mostTrusted];
                    console.log(`     Most Trusted: ${trusted ? trusted.name : 'Unknown'}`);
                }
            }
        });
        
        console.log("‚ïê".repeat(60));
    }
    
    async showInventory() {
        const gameState = this.engine.getDetailedGameState();
        
        console.log("\nüéí INVENTORY & ITEMS");
        console.log("‚ïê".repeat(50));
        
        const inventoryItems = Object.values(gameState.entities.items)
            .filter(item => item.location === 'player_inventory');
        
        if (inventoryItems.length === 0) {
            console.log("Your inventory is empty.");
        } else {
            console.log("üì¶ CARRYING:");
            inventoryItems.forEach(item => {
                console.log(`\n   ${item.name} (${item.rarity})`);
                console.log(`     Type: ${item.type}${item.subtype ? ` (${item.subtype})` : ''}`);
                console.log(`     Value: ${item.value} gold, Weight: ${item.weight} lbs`);
                console.log(`     Durability: ${item.durability}/100`);
                if (item.description) {
                    console.log(`     ${item.description}`);
                }
                if (item.enchantments && item.enchantments.length > 0) {
                    console.log(`     Enchantments: ${item.enchantments.join(', ')}`);
                }
            });
        }
        
        // Show available items in current location
        const locationItems = Object.values(gameState.entities.items)
            .filter(item => item.location === gameState.player.currentLocation);
        
        if (locationItems.length > 0) {
            console.log("\nüîç AVAILABLE IN AREA:");
            locationItems.forEach(item => {
                console.log(`   ‚Ä¢ ${item.name} (${item.rarity}) - ${item.value} gold`);
            });
        }
        
        console.log("‚ïê".repeat(50));
    }
    
    async analyzeWorld() {
        console.log("\nüîÆ ANALYZING WORLD STATE...\n");
        
        const analysis = await this.engine.aiInterface.analyzeConsequences(
            "", 
            "analyze current world state", 
            this.engine.compileGameState()
        );
        
        if (analysis && analysis.trends) {
            console.log("üìà IDENTIFIED TRENDS:");
            analysis.trends.forEach(trend => {
                const emoji = trend.direction === 'rising' ? '‚¨ÜÔ∏è' : trend.direction === 'falling' ? '‚¨áÔ∏è' : '‚û°Ô∏è';
                console.log(`   ${emoji} ${trend.description} (${trend.significance} significance)`);
            });
        }
        
        if (analysis && analysis.conflicts) {
            console.log("\n‚öîÔ∏è POTENTIAL CONFLICTS:");
            analysis.conflicts.forEach(conflict => {
                const riskEmoji = conflict.likelihood === 'high' ? 'üî¥' : conflict.likelihood === 'medium' ? 'üü°' : 'üü¢';
                console.log(`   ${riskEmoji} ${conflict.parties.join(' vs ')} (${conflict.type})`);
                console.log(`       Likelihood: ${conflict.likelihood}, Impact: ${conflict.impact}`);
            });
        }
        
        if (analysis && analysis.opportunities) {
            console.log("\nüíé OPPORTUNITIES:");
            analysis.opportunities.forEach(opp => {
                console.log(`   ‚Ä¢ ${opp.description}`);
                if (opp.requirements.length > 0) {
                    console.log(`     Requirements: ${opp.requirements.join(', ')}`);
                }
                if (opp.rewards.length > 0) {
                    console.log(`     Potential Rewards: ${opp.rewards.join(', ')}`);
                }
            });
        }
        
        console.log("\nüéØ Analysis complete!");
    }
    
    async saveGame() {
        const success = await this.engine.saveGame();
        if (success) {
            console.log("üíæ Game saved successfully!");
        } else {
            console.log("‚ùå Failed to save game.");
        }
    }
    
    async loadGame() {
        const success = await this.engine.loadGame();
        if (success) {
            console.log("üìÅ Game loaded successfully!");
        } else {
            console.log("‚ùå Failed to load game.");
        }
    }
    
    async quit() {
        console.log("\nüëã Preparing to exit...");
        
        const save = await this.askQuestion("üíæ Save before quitting? (Y/n): ");
        if (!save.toLowerCase().startsWith('n')) {
            await this.engine.saveGame();
        }
        
        console.log("\nüé≠ Thank you for experiencing the Advanced Dynamic Story Engine!");
        console.log("Your world awaits your return...");
        
        this.rl.close();
        process.exit(0);
    }
    
    askQuestion(question) {
        return new Promise((resolve) => {
            this.rl.question(question, (answer) => {
                resolve(answer);
            });
        });
    }
}

// Main execution
async function main() {
    const gameInterface = new GameInterface();
    
    try {
        await gameInterface.initialize();
        await gameInterface.gameLoop();
    } catch (error) {
        console.error("üí• Critical error occurred:", error.message);
        console.log("üîß Attempting graceful shutdown...");
        process.exit(1);
    }
}

// Enhanced shutdown handling
process.on('SIGINT', () => {
    console.log("\n\nüëã Graceful shutdown initiated...");
    console.log("üé≠ Until next time, adventurer!");
    process.exit(0);
});

process.on('uncaughtException', (error) => {
    console.error('üí• Uncaught Exception:', error);
    console.log('üîß Emergency shutdown...');
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
    console.log('üîß Emergency shutdown...');
    process.exit(1);
});

if (require.main === module) {
    main();
}

module.exports = GameInterface;